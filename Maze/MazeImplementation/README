Description:
    Last updated: 10/09/2023

    This implementation of the Maze program is an attempt at combining the Abstract Factory (and, by extention, the Factory Method) and Singleton design patterns together.
    This is done primarily through reworking the MapFactory hierarchy. Singleton behaviors have been implemented into the base class, MapFactory. Through its static GetInstance() method, the client may specify what class of the MapFactory hierarcy (including MapFactory itself) to retreive or instantiate if necessary. Through this, different factories may be used at will, simply by specifying the desired factory, and there will never be duplicate factories of the same type through this technique. Adding a new type of MapFactory only requires the addition of a child class, no changes or additions to any existing content, as MapFactory does not rely on its children at all and coupling has been minimized. Different factories will provide unique objects to be used in the creation of a Map, such as Rooms, Walls, and Doors.

    While it has not been implemented yet, this project will utilize the MazeGame to define how different mazes will be constructed. For example, it is planned that a derivation of MazeGame, say EnchantedMazeGame, will utilize the MapFactory and EnchantedMapFactory to build a map with elements from both factories.

    When running the game (via RunGame()), simple options will be provided, expecting input of those options in complete lowercase.

Start Date:
    10/6/2023

Notes:
    This program does not yet deallocate memory.

Problems/Questions (focused on the MapFactory hierarchy):
    Instantiation Restriction:
        As of now, I believe that MapFactory::GetInstance() CANNOT return anything but a MapFactory, even a nullptr. Is this true? Can I assert that MapFactory::GetInstance() will ALWAYS return a pointer to an existing MapFactory?
        The only place I see where nullptr may be set is if the dynamic_cast fails. However, I believe that if T is anything other than a member of the MapFactory hierarchy, the program will refuse to compile, since a non-MapFactory can't be dynamically cast to or from a MapFactory.
    Singleton Wrapper:
        Is there any reason to have a class that defines the singleton behavior and has a uniqueInstance of MapFactory? I don't see how this can hurt much, but does it help anything?
        * It separates the responsibility of maintaining singletonness from the responsibility of creating pieces of a map, adhering to the Single-Responsibility-Principle.
        Just think about this a little more at some point.
    Can I eliminate the need for templatizing GetInstance?
        Say instead of:
        MapFactory::GetInstance<EnchantedMapFactory>()
        I can say:
        EnchantedMapFactory::GetInstance()
        This is probably a stupid idea too lol